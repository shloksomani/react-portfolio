{"ast":null,"code":"import { isArray, isPlainObject } from 'is-what';\n\nfunction mergeRecursively(origin, newComer, extensions) {\n  // work directly on newComer if its not an object\n  if (!isPlainObject(newComer)) {\n    // extend merge rules\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newComer = extend(origin, newComer);\n      });\n    }\n\n    return newComer;\n  } // define newObject to merge all values upon\n\n\n  var newObject = isPlainObject(origin) ? Object.keys(origin).reduce(function (carry, key) {\n    var targetVal = origin[key]; // @ts-ignore\n\n    if (!Object.keys(newComer).includes(key)) carry[key] = targetVal;\n    return carry;\n  }, {}) : {};\n  return Object.keys(newComer).reduce(function (carry, key) {\n    // re-define the origin and newComer as targetVal and newVal\n    var newVal = newComer[key];\n    var targetVal = isPlainObject(origin) ? origin[key] : undefined; // extend merge rules\n\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newVal = extend(targetVal, newVal);\n      });\n    } // early return when targetVal === undefined\n\n\n    if (targetVal === undefined) {\n      carry[key] = newVal;\n      return carry;\n    } // When newVal is an object do the merge recursively\n\n\n    if (isPlainObject(newVal)) {\n      carry[key] = mergeRecursively(targetVal, newVal, extensions);\n      return carry;\n    } // all the rest\n\n\n    carry[key] = newVal;\n    return carry;\n  }, newObject);\n}\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\n\n\nfunction index(origin) {\n  var newComers = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    newComers[_i - 1] = arguments[_i];\n  }\n\n  var extensions = null;\n  var base = origin;\n\n  if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\n    base = {};\n    extensions = origin.extensions;\n  }\n\n  return newComers.reduce(function (result, newComer) {\n    return mergeRecursively(result, newComer, extensions);\n  }, base);\n}\n\nexport default index;","map":{"version":3,"sources":["C:/Users/jlpan/RPortfolio/react-portfolio/node_modules/merge-anything/dist/index.esm.js"],"names":["isArray","isPlainObject","mergeRecursively","origin","newComer","extensions","forEach","extend","newObject","Object","keys","reduce","carry","key","targetVal","includes","newVal","undefined","index","newComers","_i","arguments","length","base","result"],"mappings":"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","sourcesContent":["import { isArray, isPlainObject } from 'is-what';\n\nfunction mergeRecursively(origin, newComer, extensions) {\r\n    // work directly on newComer if its not an object\r\n    if (!isPlainObject(newComer)) {\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newComer = extend(origin, newComer);\r\n            });\r\n        }\r\n        return newComer;\r\n    }\r\n    // define newObject to merge all values upon\r\n    var newObject = (isPlainObject(origin))\r\n        ? Object.keys(origin)\r\n            .reduce(function (carry, key) {\r\n            var targetVal = origin[key];\r\n            // @ts-ignore\r\n            if (!Object.keys(newComer).includes(key))\r\n                carry[key] = targetVal;\r\n            return carry;\r\n        }, {})\r\n        : {};\r\n    return Object.keys(newComer)\r\n        .reduce(function (carry, key) {\r\n        // re-define the origin and newComer as targetVal and newVal\r\n        var newVal = newComer[key];\r\n        var targetVal = (isPlainObject(origin))\r\n            ? origin[key]\r\n            : undefined;\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newVal = extend(targetVal, newVal);\r\n            });\r\n        }\r\n        // early return when targetVal === undefined\r\n        if (targetVal === undefined) {\r\n            carry[key] = newVal;\r\n            return carry;\r\n        }\r\n        // When newVal is an object do the merge recursively\r\n        if (isPlainObject(newVal)) {\r\n            carry[key] = mergeRecursively(targetVal, newVal, extensions);\r\n            return carry;\r\n        }\r\n        // all the rest\r\n        carry[key] = newVal;\r\n        return carry;\r\n    }, newObject);\r\n}\r\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\r\nfunction index (origin) {\r\n    var newComers = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        newComers[_i - 1] = arguments[_i];\r\n    }\r\n    var extensions = null;\r\n    var base = origin;\r\n    if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\r\n        base = {};\r\n        extensions = origin.extensions;\r\n    }\r\n    return newComers.reduce(function (result, newComer) {\r\n        return mergeRecursively(result, newComer, extensions);\r\n    }, base);\r\n}\n\nexport default index;\n"]},"metadata":{},"sourceType":"module"}